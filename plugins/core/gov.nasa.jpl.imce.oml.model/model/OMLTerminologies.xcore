@Ecore(
	nsPrefix="omlt", 
	nsURI="http://imce.jpl.nasa.gov/oml/terminologies"
)
@GenModel(
	copyrightText="\nCopyright 2017 California Institute of Technology (\"Caltech\").\nU.S. Government sponsorship acknowledged.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n",
	modelPluginVariables="org.eclipse.xtext.xbase.lib org.eclipse.emf.ecore.xcore.lib org.eclipse.emf.cdo",
	rootExtendsClass="org.eclipse.emf.internal.cdo.CDOObjectImpl",
	rootExtendsInterface="org.eclipse.emf.cdo.CDOObject",
	childCreationExtenders="true",
	complianceLevel="8.0",
	featureDelegation="None",
	modelDirectory="/gov.nasa.jpl.imce.oml.model/src-gen/",
	editDirectory="/gov.nasa.jpl.imce.oml.model.edit/src-gen/",
	editPluginClass="gov.nasa.jpl.imce.oml.model.edit.provider.OMLEditPlugin"
)
package gov.nasa.jpl.imce.oml.model.terminologies
/**
 * Copyright 2017 California Institute of Technology (\"Caltech\").
 * U.S. Government sponsorship acknowledged.
 * 
 * Licensed under the Apache License, Version 2.0 (the \"License\")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an \"AS IS\" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 */

import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.common.util.ECollections

import gov.nasa.jpl.imce.oml.model.extensions.OMLExtensions

import gov.nasa.jpl.imce.oml.model.common.Collection
import gov.nasa.jpl.imce.oml.model.common.CopyConstructor
import gov.nasa.jpl.imce.oml.model.common.LiteralDateTime
import gov.nasa.jpl.imce.oml.model.common.DerivedUUID
import gov.nasa.jpl.imce.oml.model.common.Element
import gov.nasa.jpl.imce.oml.model.common.Factory
import gov.nasa.jpl.imce.oml.model.common.FunctionalInterface
import gov.nasa.jpl.imce.oml.model.common.Glossary
import gov.nasa.jpl.imce.oml.model.common.ImplicitExtent
import gov.nasa.jpl.imce.oml.model.common.IRI
import gov.nasa.jpl.imce.oml.model.common.IRIReference
import gov.nasa.jpl.imce.oml.model.common.LanguageTagDataType
import gov.nasa.jpl.imce.oml.model.common.LiteralValue
import gov.nasa.jpl.imce.oml.model.common.LocalName
import gov.nasa.jpl.imce.oml.model.common.Module
import gov.nasa.jpl.imce.oml.model.common.ModuleEdge
import gov.nasa.jpl.imce.oml.model.common.ModuleElement
import gov.nasa.jpl.imce.oml.model.common.NamespaceUUID
import gov.nasa.jpl.imce.oml.model.common.NotFunctionalAPI
import gov.nasa.jpl.imce.oml.model.common.NotSchema
import gov.nasa.jpl.imce.oml.model.common.LiteralNumber
import gov.nasa.jpl.imce.oml.model.common.LiteralPattern
import gov.nasa.jpl.imce.oml.model.common.Override
import gov.nasa.jpl.imce.oml.model.common.OverrideVal
import gov.nasa.jpl.imce.oml.model.common.PositiveIntegerLiteral
import gov.nasa.jpl.imce.oml.model.common.Resource
import gov.nasa.jpl.imce.oml.model.common.Scala
import gov.nasa.jpl.imce.oml.model.common.UUID


/*
 * OML supports two different interpretations for OML TerminologyBox vocabularies:
 * - An open-world interpretation where the vocabulary formalizes a particular domain 
 *   that will be used for modeling particular systems in that domain.
 * - A closed-world interpretation where the vocabulary formalizes the description of
 *   a particular system modeled using the open-world vocabulary for a particular domain.
 * The difference between these interpretations primarily affects the mapping to an [OWL2-DL Class]
 * of a concrete OML ConceptualEntity as follows:
 * - For OpenWorldDefinitions, the mapped [OWL2-DL Class] has open-world semantics; that is,
 *   it classifies a set of individuals that share the characteristics and capabilities 
 *   encoded in the [OWL2-DL Class].
 * - For ClosedWorldDefinitions, the mapped [OWL2-DL Class] has a closed-world semantics in
 *   the sense that it is intended to classify a singleton individual uniquely identified
 *   via the values of its identifying OML DataRelationshipFromEntity properties.
 */
@Glossary
enum TerminologyKind {
	/*
	 * Each OML Entity in an OpenWorldDefinitions OML TerminologyBox has the semantics of
	 * an [OWL2-DL Class]; that is, it classifies a set of individuals 
	 * that share the characteristics and capabilities encoded in the [OWL2-DL Class].
	 * A well-formed OML SpecializationAxiom establishing a taxonomic relationship between 
	 * two OML Term(s) can be asserted arbitrarily in any OpenWorldDefinitions OML TerminologyBox 
	 * that directly or indirectly includes the related OML Term(s). 
	 * For example, suppose that OML Concept(s) `A` and `B`
	 * are defined in OpenWorldDefinitions OML TerminologyBox `P` and `Q` respectively. 
	 * Suppose further that OpenWorldDefinitions OML TerminologyBox(es), `U` and `V`, each
	 * extend both `P` and `Q` where `U` asserts that `A` extends `B` while `V` asserts that `B` extends `A.
	 * This is well-formed; furthermore, an OpenWorldDefinitions OML TerminologyBox extending both `U` and `V` 
	 * would force `A` and `B` to become equivalent OML Concept(s) per the open-world semantics of [OWL2-DL].
	 */
	OpenWorldDefinitions
	/*
	 * Each OML ConceptualEntity in a ClosedWorldDesignation terminology describes a unique thing 
	 * in the real world uniquely identifiable by the collection of its identifying OML DataRelationshipFromEntity properties
	 * (e.g., serial numbers, unique identifiers, ...).
	 * A well-formed ClosedWorldDesignations OML TerminologyBox is restricted to defining singleton OML ConceptualEntity(-ies), each as
	 * a specialization of at least one concrete OML ConceptualEntity defined  in an extended OpenWorldDefinitions OML TerminologyBox.
	 * Each OML ConceptualEntity in a ClosedWorldDesignations OML TerminologyBox maps to
	 * an [OWL2-DL Class] with an axiom asserting its equivalence to an exact cardinality restriction of 1 for
	 * each of its identifying OML DataRelationshipFromEntity properties.
	 */
	ClosedWorldDesignations
}

/*
 * An OML TerminologyBox is an OML Module for defining a domain-specific vocabulary
 * as a logical set of OML TerminologyBoxStatement(s), possibly by reuse of other 
 * vocabularies via OML TerminologyBoxAxiom(s).
 * The semantics of an OML TerminologyBox domain-specific vocabulary is defined
 * by the mapping to [OWL2-DL] of the other vocabularies it reuses, if any, and
 * that of its OML TerminologyBoxAxiom(s) and OML TerminologyBoxStatement(s) 
 * according to its OML TerminologyKind. 
 */
@Glossary
abstract class TerminologyBox extends Module {
	
	TerminologyKind[1] kind
	
	/*
	 * The OML TerminologyBoxAxiom(s) asserted in this OML TerminologyBox
	 */
	@NotSchema
	@Collection(kind="Set")
	contains TerminologyBoxAxiom[] boxAxioms opposite tbox
	
	/*
	 * The OML TerminologyBoxStatement(s) asserted in this OML TerminologyBox
	 */
	@NotSchema
	@Collection(kind="Set")
	contains TerminologyBoxStatement[] boxStatements opposite tbox
}

/*
 * An OML TerminologyBoxStatement is a logical axiom about an OML TerminologyThing
 * in an OML TerminologyBox.
 */
@Glossary
abstract class TerminologyBoxStatement extends ModuleElement {
	
	@Factory
	container TerminologyBox[1] tbox opposite boxStatements
	
	@Scala(code="extent.terminologyBoxOfTerminologyBoxStatement.get(this)")
	@NotSchema
	@ImplicitExtent
	op Module[?] moduleContext() { tbox }
}

/*
 * An OML TerminologyAxiom is asserted in an OML TerminologyBox of some kind.
 */
@Glossary
abstract class TerminologyAxiom extends ModuleEdge {
	
	/*
	 * The source TerminologyBox
	 */
	@NotSchema
	@ImplicitExtent
	op TerminologyBox[?] source()
	
	@NotSchema
	@ImplicitExtent
	op Module[?] sourceModule() { source() }
	
	/*
	 * The target TerminologyBox
	 */
	@IRIReference
  	@NotSchema
	@ImplicitExtent
	op TerminologyBox[1] target()
	
	@IRIReference
  	@NotSchema
	@ImplicitExtent
	op Module[1] targetModule() { target() }
}

/*
 * An OML TerminologyBoxAxiom is an OML TerminologyAxiom that
 * asserts a logical statement about an OML TerminologyBox.
 */
@Glossary
abstract class TerminologyBoxAxiom extends TerminologyAxiom {
	
	@CopyConstructor
	container TerminologyBox[1] tbox opposite boxAxioms
}

/*
 * An OML TerminologyExtensionAxiom allows an extendingTerminology to
 * make references (via OML TerminologyBoxStatement(s)) to OML TerminologyThing(s)
 * declared within the transitive closure of the extendedTerminlogy.
 */
@Glossary
@DerivedUUID
class TerminologyExtensionAxiom extends TerminologyBoxAxiom {

	@Scala(code="extent.terminologyBoxOfTerminologyBoxAxiom.get(this)")
	@ImplicitExtent
	@NotSchema
	op TerminologyBox[?] extendingTerminology() { tbox }
	
	@IRIReference
  	refers TerminologyBox[1] extendedTerminology
  	
	/*
	 * The extendingTerminology is the source
	 */
	@ImplicitExtent
	@NotSchema
	@Override
	op TerminologyBox[?] source() { extendingTerminology() }
	
	/*
	 * The extendedTerminology is the target
	 */
	@IRIReference
  	@ImplicitExtent
	@NotSchema
	@Override
	op TerminologyBox[1] target() { extendedTerminology }
  	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"TerminologyExtensionAxiom", 
		"tbox" -> tbox?.uuid()?.toString,
		"extendedTerminology" -> extendedTerminology?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML Term map to the declaration of an [OWL2-DL Entity] of some kind.
 */
@Glossary
@NamespaceUUID(namespace="tbox", factors="name")
abstract class Term extends TerminologyBoxStatement, Resource {
	
	@Scala(code="extent.terminologyBoxOfTerminologyBoxStatement.get(this).flatMap(_.iri().map(_ + \"#\" + name))")
	@ImplicitExtent
	@NotSchema
	@Override
	op IRI[?] iri() { tbox?.iri()+'#'+name() }
	
	@Scala(code="extent.terminologyBoxOfTerminologyBoxStatement.get(this).map(tbox => tbox.nsPrefix+\":\"+name)")
	@ImplicitExtent
	@NotSchema
	@Override
	op String[?] abbrevIRI() { (tbox?.nsPrefix()?:"")+':'+name() }
	
	@Override
	LocalName[1] name
	
	@NotFunctionalAPI
	@NotSchema
	op LocalName[1] name() { getName() }
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.namespaceUUID(tbox?.uuid(), "name" -> name()?.toString())?.toString
	}
	
	@Scala(code="scala.collection.immutable.Set.empty[resolver.api.Element]")
	@Collection(kind="Set")
	@NotSchema
	@ImplicitExtent
	op Element[] allNestedElements() { ECollections.emptyEList }
}

/*
 * An OML UnaryTermKind is an abstraction for the category of OML Term(s)
 * that are relationships with arity 1
 */
@Glossary
abstract class UnaryTermKind {}

/*
 * An OML DirectedBinaryRelationshipKind is an abstraction 
 * for the category of OML Term(s)
 * that are relationships with arity 2
 */
@Glossary
abstract class DirectedBinaryRelationshipKind {
	
	@NotSchema
	op Term[1] relationDomain()
	
	@NotSchema
	op Term[1] relationRange()
}

/*
 * An OML Entity is an abstraction for an OML Term
 * that is either an OML UnaryTermKind or
 * an OML DirectedBinaryRelationshipKind whose subject
 * and range are both a kind of OML Entity.
 */
@Glossary
abstract class Entity extends Term {}

/*
 * An OML ConceptualEntity is an OML Entity that can be instantiated
 * as an OML ConceptualEntitySingletonInstance in any OML DescriptionBox.
 * It is partially instantiated if some essential OML EntityRelationship
 * or OML DataRelationshipFromEntity with `isIdentityCriteria=true` lacks
 * an OML TerminologyInstanceAssertion specifying its reference or value respectively.
 */
@Glossary
abstract class ConceptualEntity {}

/*
 * An OML Aspect is a kind of OML Entity of OML UnaryTermKind.
 * It is intended to be used as a specialization parent
 * for one or more OML ConceptualEntity.
 */
@Glossary
class Aspect extends Entity, UnaryTermKind {}

/*
 * An OML Concept is an OML ConceptualEntity of OML UnaryTermKind.
 */
@Glossary
class Concept extends Entity, ConceptualEntity, UnaryTermKind {}

/*
 * An OML EntityRelationship is a kind of OML Term that
 * is an OML DirectedBinaryRelationshipKind between a
 * domain OML Entity and a range OML Entity.
 */
@Glossary
abstract class EntityRelationship extends Term, DirectedBinaryRelationshipKind {

 	refers Entity[1] source

	@NotSchema
	@Override
	op Term[1] relationDomain() { source }

 	refers Entity[1] target

	@NotSchema
	@Override
	op Term[1] relationRange() { target }
	
 	/*
 	 * 0 <= target.size <= 1
	 */
	boolean[1] isFunctional
 	/*
 	 * 0 <= source.size <= 1
	 */ 	 
 	boolean[1] isInverseFunctional
 	/*
 	 * 1 <= target.size
	 */
 	boolean[1] isEssential
 	/*
 	 * 1 <= source.size 	
	 */
 	boolean[1] isInverseEssential
 	/*
 	 * Whether this relationship is symmetric
	 */
 	boolean[1] isSymmetric
 	/*
 	 * Whether this relationship is asymmetric
	 */
 	boolean[1] isAsymmetric
 	/*
 	 * Whether this relationship is reflexive
	 */
 	boolean[1] isReflexive
 	/*
 	 * Whether this relationship is irreflexive
	 */ 	 
 	boolean[1] isIrreflexive
 	/*
 	 * Whether this relationship is transitive
	 */
 	boolean[1] isTransitive
}

/*
 * An OML ReifiedRelationship is an OML ConceptualEntity and a kind of OML EntityRelationship
 * where an instance has an intrinsic identity. This means that
 * an OML ReifiedRelationship can be involved as the domain or the
 * range of another OML EntityRelationship as well as the
 * domain of an OML DataRelationshipFromEntity.
 */
@Glossary
class ReifiedRelationship extends EntityRelationship, Entity, ConceptualEntity {

	LocalName[1] unreifiedPropertyName
	LocalName[?] unreifiedInversePropertyName
}

/*
 * An OML UnreifiedRelationship is a kind of OML EntityRelationship
 * where an instance has no intrinsic identity but rather structural
 * equivalence semantics as a tuple of references. This means
 * that an OML UnreifiedRelationship cannot be involved as the domain
 * or range of any kind of OML DirectedBinaryRelationshipKind.
 */
@Glossary
class UnreifiedRelationship extends EntityRelationship {}

/*
 * An OML Datatype is a common abstraction for what should be, in principle,
 * [OWL2 DataRange] of arity 1 (atomic) or > 1 (tuple structure).
 * In practice, an OML DataType maps to the [OWL2-DL] subset; which means
 * that an atomic OML Datatype maps to an [OWL2 Datatype] whereas
 * a structured OML Datatype maps to an [OWL2 Class].
 */
@Glossary
abstract class Datatype extends Term {}

/*
 * An OWL DataRange corresponds to an [OWL2 DataRange] with arity=1.
 */
@Glossary
abstract class DataRange extends Datatype {}

/*
 * An OML Scalar corresponds to an OWL2 Declaration of an [OWL2 DataRange] with arity=1.
 */
@Glossary
class Scalar extends DataRange, UnaryTermKind {}

/*
 * An OML DataRelationship is an OML DirectedBinaryRelationshipKind
 * where the domain or the range is some kind of OML Datatype.
 */
@Glossary
abstract class DataRelationship extends Term, DirectedBinaryRelationshipKind {
	
	@NotSchema
	op Term[1] source()
	
	@NotSchema
	@Override
	op Term[1] relationDomain() { source }
	
	@NotSchema
	op Datatype[1] target()
	
	@NotSchema
	@Override
	op Term[1] relationRange() { target }
}

/*
 * An OML DataRelationshipDomain is an abstraction 
 * for the domain of an OML DataRelationship
 */
@Glossary
abstract class DataRelationshipDomain extends ModuleElement, Resource {
}

/*
 * An OML DataRelationshipFromEntity is an OML DataRelationship
 * whose domain is an OML Entity.
 */
@Glossary
abstract class DataRelationshipFromEntity extends DataRelationshipDomain {
	refers Entity[1] domain
	
	/*
	 * Specifies the OntoClean IdentityCriteria semantics of an OML DataRelationshipFromEntity:
	 * - +IC, if true; which means that every OML ConceptualEntity defined in a ClosedWorldDesignations OML Terminology
	 *   has an exact cardinality restriction of 1 for the possible values of the relationship, which is an
	 *   encoding in [OWL2-DL] of
	 * - ~IC, if false
	 */
	@Glossary
	boolean[1] isIdentityCriteria
}

/*
 * An OML DataRelationshipFromStructure is an OML DataRelationship
 * whose domain is an OML Structure.
 */
@Glossary
abstract class DataRelationshipFromStructure extends DataRelationshipDomain {
	refers Structure[1] domain
}

/*
 * An OML DataRelationshipRange is an abstraction 
 * for the range of an OML DataRelationship
 */
@Glossary
abstract class DataRelationshipRange extends ModuleElement, Resource {
}

/*
 * An OML DataRelationshipToScalar is an OML DataRelationship 
 * whose range is an OML DataRange.
 */
@Glossary
abstract class DataRelationshipToScalar extends DataRelationshipRange {
	refers DataRange[1] range
}

/*
 * An OML DataRelationshipToStructure is an OML DataRelationship 
 * whose range is an OML Structure.
 */
@Glossary
abstract class DataRelationshipToStructure extends DataRelationshipRange {
	refers Structure[1] range
}

/*
 * An OML EntityStructuredDataProperty is an OML DataRelationship
 * whose domain is an OML Entity and range is an OML Structure.
 */
@Glossary
class EntityStructuredDataProperty extends DataRelationship, DataRelationshipFromEntity, DataRelationshipToStructure {
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid()
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML EntityScalarDataProperty is an OML DataRelationship
 * whose domain is an OML Entity and range is an OML DataRange.
 */
@Glossary
class EntityScalarDataProperty extends DataRelationship, DataRelationshipFromEntity, DataRelationshipToScalar {
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid()
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML StructuredDataProperty is an OML DataRelationship
 * whose domain is an OML Structure and range is an OML Structure.
 */
@Glossary
class StructuredDataProperty extends DataRelationship, DataRelationshipFromStructure, DataRelationshipToStructure {
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid()
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML ScalarDataProperty is an OML DataRelationship
 * whose domain is an OML Structure and range is an OML DataRange.
 */
@Glossary
class ScalarDataProperty extends DataRelationship, DataRelationshipFromStructure, DataRelationshipToScalar {
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid()
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML Structure would correspond to an OWL2 Declaration of an [OWL2 DataRange] with arity > 1.
 * However, since OWL2 Datatypes in the [OWL2-DL] are restricted to have arity=1,
 * the OML mapping to [OWL2-DL] involves a pattern-based usage of an [OWL2 Class] to represent an OML Structure.
 * The arity corresponds to the cardinality of the set of ScalarDataProperty & StructuredDataProperty 
 * relationships whose domain is this structure.
 */
@Glossary
class Structure extends Datatype, UnaryTermKind {}

/*
 * An OML Rule corresponds to a labelled SWRL rule.
 */
@Glossary
abstract class Rule extends Term {}

/*
 * An OML ChainRule corresponds to a named SWRL implication rule 
 * whose consequent head is a single OML UnreifiedRelationship, `ur`,
 * and whose antecedent body consists of at least 1 OML RuleBodySegment
 * possibly followed by other OML RuleBodySegment(s).
 * 
 * SWRL variables are implicit in OML in the following sense:
 * - The consequent head, `ur` is a binary predicate: `ur(?d, ?r)` 
 *   where `?d` and `?r` are variables corresponding to, respectively,
 *   the domain and range of the OML UnreifiedRelationship `ur`.
 * - `?d` is the first variable of the OML Term used as the `termPredicate` of the `firstSegment`;
 * - `?r` is the last variable of the OML Term used as the `termPredicate` of the last OML RuleBodySegment;
 * - for an OML RuleBodySegment at `position` `i` that has a `nextSegment` at `position` `i+1`,
 *   the last variable of the OML Term used as the `termPredicate` at `i` must be identical
 *   to the first variable of the OML Term used as the `termPredicate` at `i+1;
 * - for an OML RuleBodySegment whose `segmentPrediccate` is an OML UnarySegmentPredicate,
 *   the `termPredicate` is unary and its unique variable plays the roles of both first and last variables;
 * - for an OML RuleBodySegment whose `segmentPredicate` is an OML BinarySegmentForwardPropertyPredicate,
 *   the `termPredicate` is binary and its first and second variables correspond respectively 
 *   to the domain and range of the property interpreted in the forward direction from its domain to its range;
 * - for an OML RuleBodySegment whose `segmentPredicate` is an OML BinarySegmentReversePropertyPredicate,
 *   the `termPredicate` is binary and its first and second variables correspond respectively 
 *   to the range and domain of the property interpreted in the reverse direction from its range to its domain.
 */
@Glossary
class ChainRule extends Rule {
	
	refers UnreifiedRelationship[1] head
	
	contains RuleBodySegment[1] firstSegment opposite rule
	
}

/*
 * An OML RuleBodySegment corresponds to a predicate in the body of a SWRL rule.
 * The `position` of an OML RuleBodySegment is 1 for the firstBodySegment of an OML ChainRule.
 * If the `position` of the current OML RuleBodySegment is `p`, 
 * then the `position` of the `nextSegment`, if defined, is `p+1`.
 */
@Glossary
class RuleBodySegment extends Element {
	
	contains SegmentPredicate[1] predicate opposite bodySegment
	
	contains RuleBodySegment[?] nextSegment opposite previousSegment
	
	container RuleBodySegment[?] previousSegment opposite nextSegment
	
	container ChainRule[?] rule opposite firstSegment
	
	@Scala(code="previousSegment match { 
					case scala.None => 
						1
					case scala.Some(prev) => 
						1 + prev.position()
				}")
	@NotSchema
	op int[1] position() { 
		if (null === previousSegment) 1
		else 1 + previousSegment.position
	}
	
	@Scala(code="rule match {
					case scala.Some(r) =>
						r
					case scala.None =>
						previousSegment match {
							case scala.Some(prev) =>
								prev.chainRule()
							case scala.None =>
								throw new java.lang.IllegalArgumentException(\"chainRule() must be well-defined\")
						}				}")
	@NotSchema
	op ChainRule[1] chainRule() {
		rule?:previousSegment?.chainRule
	}
	
	@Scala(code="namespaceUUID(\"RuleBodySegment\",  
		\"chainRule\" -> 
			rule.fold[scala.Predef.String]{ 
			  previousSegment.fold[scala.Predef.String]{ throw new java.lang.IllegalArgumentException(\"rule or previousSegment must be non-empty\") }{ prev => 
				prev.chainRule().uuid.toString
			  } 
			}{ r => 
			  r.uuid.toString },
		\"position\" -> 
			previousSegment.fold[scala.Predef.String] { 
			  \"1\" 
			}{ prev => 
			  (1 + prev.position()).toString 
			})")
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"RuleBodySegment",
		"chainRule" -> if (null === previousSegment)
			chainRule?.uuid()?.toString
		else 
			previousSegment.chainRule()?.toString,
		"position" -> if (null === previousSegment) 
			"1"
			else
				(1 + previousSegment.position()).toString
		)?.toString
	}
	
	@Scala(code="chainRule().moduleContext()")
	@NotSchema
	@ImplicitExtent
	op Module[?] moduleContext() { rule?.moduleContext() }
}

/*
 * An OML SegmentPredicate wraps a reference to an OML Term used as a predicate for an OML ChainRule.
 */
@Glossary
abstract class SegmentPredicate extends Element {
	
	container RuleBodySegment[1] bodySegment opposite predicate
	
	@NotSchema
	op Term[1] termPredicate()
	
	@NotSchema
	@ImplicitExtent
	op Module[?] moduleContext() { bodySegment.moduleContext() }
}

/*
 * An OML UnarySegmentPredicate wraps a reference to an OML Term used as a unary predicate for an OML ChainRule.
 */
@Glossary
abstract class UnarySegmentPredicate extends SegmentPredicate {}

/*
 * An OML AspectPredicate wraps a reference 
 * to an OML Aspect as a unary predicate for an OML ChainRule.
 * This unary predicate is satisfied when its implicit variable is bound 
 * to an instance of the referenced OML Aspect.
 */
@Glossary
class AspectPredicate extends UnarySegmentPredicate {
	
	refers Aspect[1] aspect
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { aspect }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"AspectPredicate",
		"aspect" -> aspect?.uuid()?.toString,
		"bodySegment" -> bodySegment?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML ConceptPredicate wraps a reference 
 * to an OML Concept as a unary predicate for an OML ChainRule.
 * This unary predicate is satisfied when its implicit variable is bound 
 * to an instance of the referenced OML Concept.
 */
@Glossary
class ConceptPredicate extends UnarySegmentPredicate {
	
	refers Concept[1] concept
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { concept }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ConceptPredicate",
		"bodySegment" -> bodySegment?.uuid()?.toString,
		"concept" -> concept?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML ReifiedRelationshipPredicate wraps a reference 
 * to an OML ReifiedRelationship as a unary predicate for an OML ChainRule.
 * This unary predicate is satisfied when its implicit variable is bound 
 * to an instance of the referenced OML ReifiedRelationship.
 */
@Glossary
class ReifiedRelationshipPredicate extends UnarySegmentPredicate {
	
	refers ReifiedRelationship[1] reifiedRelationship
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { reifiedRelationship }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ReifiedRelationshipPredicate",
		"bodySegment" -> bodySegment?.uuid()?.toString,
		"reifiedRelationship" -> reifiedRelationship?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML BinarySegmentPredicate wraps a reference to an OML Term used as a binary predicate for an OML ChainRule.
 */
@Glossary
abstract class BinarySegmentPropertyPredicate extends SegmentPredicate {}

/*
 * An OML BinarySegmentForwardPropertyPredicate wraps a reference to an OML Term used as a binary property predicate for an OML ChainRule
 * in the forward direction, that is, the first and second variables of this predicate correspond respectively
 * to the domain and range of the binary property predicate.
 */
@Glossary
abstract class BinarySegmentForwardPropertyPredicate extends BinarySegmentPropertyPredicate {}

/*
 * An OML BinarySegmentReversePropertyPredicate wraps a reference to an OML Term used as a binary property predicate for an OML ChainRule
 * in the reverse direction, that is, the first and second variables of this predicate correspond respectively
 * to the range and domain of the binary property predicate.
 */
@Glossary
abstract class BinarySegmentReversePropertyPredicate extends BinarySegmentPropertyPredicate {}

/*
 * An OML ReifiedRelationshipPropertyPredicate wraps a reference 
 * to an OML ReifiedRelationship as a binary predicate for an OML ChainRule.
 * This binary predicate is satisfied when the pair of its implicit variables are bound as follows:
 * - the first variable is bound to an instance suitable for the domain of the OML ReifiedRelationship;
 * - the second variable is bound to an instance suitable for the range of the OML ReifiedRelationship;
 * - there must be an instance of the OML ReifiedRelationship relating the first variable (domain) to the second variable (range).
 */
@Glossary
class ReifiedRelationshipPropertyPredicate extends BinarySegmentForwardPropertyPredicate {
	
	refers ReifiedRelationship[1] reifiedRelationship
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { reifiedRelationship }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ReifiedRelationshipPropertyPredicate",
		"bodySegment" -> getBodySegment?.uuid()?.toString,
		"reifiedRelationship" -> getReifiedRelationship?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML ReifiedRelationshipInversePropertyPredicate wraps a reference 
 * to an OML ReifiedRelationship as a binary predicate for an OML ChainRule.
 * This binary predicate is satisfied when the pair of its implicit variables are bound as follows:
 * - the first variable is bound to an instance suitable for the range of the OML ReifiedRelationship;
 * - the second variable is bound to an instance suitable for the domain of the OML ReifiedRelationship;
 * - there must be an instance of the OML ReifiedRelationship relating the second variable (domain) to the first variable (range).
 */
@Glossary
class ReifiedRelationshipInversePropertyPredicate extends BinarySegmentReversePropertyPredicate {
	
	refers ReifiedRelationship[1] reifiedRelationship
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { reifiedRelationship }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ReifiedRelationshipInversePropertyPredicate",
		"bodySegment" -> getBodySegment?.uuid()?.toString,
		"reifiedRelationship" -> getReifiedRelationship?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML ReifiedRelationshipSourcePropertyPredicate wraps a reference 
 * to an OML ReifiedRelationship as a binary predicate for an OML ChainRule.
 * This binary predicate is satisfied when the pair of its implicit variables are bound as follows:
 * - the first variable is bound to an instance of the OML ReifiedRelationship;
 * - the second variable is bound to an instance suitable for the domain of the OML ReifiedRelationship.
 */
@Glossary
class ReifiedRelationshipSourcePropertyPredicate extends BinarySegmentForwardPropertyPredicate {
	
	refers ReifiedRelationship[1] reifiedRelationship
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { reifiedRelationship }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ReifiedRelationshipSourcePropertyPredicate",
		"bodySegment" -> getBodySegment?.uuid()?.toString,
		"reifiedRelationship" -> getReifiedRelationship?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML ReifiedRelationshipSourceInversePropertyPredicate wraps a reference 
 * to an OML ReifiedRelationship as a binary predicate for an OML ChainRule.
 * This binary predicate is satisfied when the pair of its implicit variables are bound as follows:
 * - the first variable is bound to an instance suitable for the domain of the OML ReifiedRelationship;
 * - the second variable is bound to an instance of the OML ReifiedRelationship.
 */
@Glossary
class ReifiedRelationshipSourceInversePropertyPredicate extends BinarySegmentReversePropertyPredicate {
	refers ReifiedRelationship[1] reifiedRelationship
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { reifiedRelationship }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ReifiedRelationshipSourceInversePropertyPredicate",
		"bodySegment" -> getBodySegment?.uuid()?.toString,
		"reifiedRelationship" -> getReifiedRelationship?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML ReifiedRelationshipTargetPropertyPredicate wraps a reference 
 * to an OML ReifiedRelationship as a binary predicate for an OML ChainRule.
 * This binary predicate is satisfied when the pair of its implicit variables are bound as follows:
 * - the first variable is bound to an instance of the OML ReifiedRelationship;
 * - the second variable is bound to an instance suitable for the range of the OML ReifiedRelationship.
 */
@Glossary
class ReifiedRelationshipTargetPropertyPredicate extends BinarySegmentForwardPropertyPredicate {
	refers ReifiedRelationship[1] reifiedRelationship
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { reifiedRelationship }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ReifiedRelationshipTargetPropertyPredicate",
		"bodySegment" -> getBodySegment?.uuid()?.toString,
		"reifiedRelationship" -> getReifiedRelationship?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML ReifiedRelationshipTargetInversePropertyPredicate wraps a reference 
 * to an OML ReifiedRelationship as a binary predicate for an OML ChainRule.
 * This binary predicate is satisfied when the pair of its implicit variables are bound as follows:
 * - the first variable is bound to an instance suitable for the range of the OML ReifiedRelationship;
 * - the second variable is bound to an instance of the OML ReifiedRelationship.
 */
@Glossary
class ReifiedRelationshipTargetInversePropertyPredicate extends BinarySegmentReversePropertyPredicate {
	refers ReifiedRelationship[1] reifiedRelationship
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { reifiedRelationship }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ReifiedRelationshipTargetInversePropertyPredicate",
		"bodySegment" -> getBodySegment?.uuid()?.toString,
		"reifiedRelationship" -> getReifiedRelationship?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML UnreifiedRelationshipPropertyPredicate wraps a reference 
 * to an OML UnreifiedReifiedRelationship as a binary predicate for an OML ChainRule.
 * This binary predicate is satisfied when the pair of its implicit variables are bound as follows:
 * - the first variable is bound to an instance suitable for the domain of the OML UnreifiedRelationship;
 * - the second variable is bound to an instance suitable for the range of the OML UnreifiedRelationship.
 */
@Glossary
class UnreifiedRelationshipPropertyPredicate extends BinarySegmentForwardPropertyPredicate {
	refers UnreifiedRelationship[1] unreifiedRelationship
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { unreifiedRelationship }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"UnreifiedRelationshipPropertyPredicate",
		"unreifiedRelationship" -> getUnreifiedRelationship?.uuid()?.toString,
		"bodySegment" -> getBodySegment?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML UnreifiedRelationshipInversePropertyPredicate wraps a reference 
 * to an OML UnreifiedReifiedRelationship as a binary predicate for an OML ChainRule.
 * This binary predicate is satisfied when the pair of its implicit variables are bound as follows:
 * - the first variable is bound to an instance suitable for the range of the OML UnreifiedRelationship;
 * - the second variable is bound to an instance suitable for the domain of the OML UnreifiedRelationship.
 */
@Glossary
class UnreifiedRelationshipInversePropertyPredicate extends BinarySegmentReversePropertyPredicate {
	refers UnreifiedRelationship[1] unreifiedRelationship
	
	@NotSchema
	@Override
	op Term[1] termPredicate() { unreifiedRelationship }
	
	@FunctionalInterface
	@OverrideVal
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"UnreifiedRelationshipInversePropertyPredicate",
		"bodySegment" -> getBodySegment?.uuid()?.toString,
		"unreifiedRelationship" -> getUnreifiedRelationship?.uuid()?.toString
		)?.toString
	}	
}

/*
 * An OML TermAxiom is a logical axiom about an OML Term.
 */
@Glossary
abstract class TermAxiom extends TerminologyBoxStatement {}

/*
 * An OML EntityRestrictionAxiom maps to an [OWL2 Object Property Restiction]
 * for an OML EntityRelationship.
 */
@Glossary
abstract class EntityRestrictionAxiom extends TermAxiom {

	 refers EntityRelationship[1] restrictedRelation

	 refers Entity[1] restrictedRange

	 refers Entity[1] restrictedDomain
	 
	@Scala(code="scala.collection.immutable.Set.empty[resolver.api.Element]")
	@Collection(kind="Set")
	@NotSchema
	@ImplicitExtent
	op Element[] allNestedElements() { ECollections.emptyEList }
}

/*
 * An OML EntityExistentialRestrictionAxiom maps 
 * to an [OWL2 Object Property Existential Restriction].
 */
@Glossary
@DerivedUUID
class EntityExistentialRestrictionAxiom extends EntityRestrictionAxiom {
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"EntityExistentialRestrictionAxiom", 
		"tbox" -> tbox.uuid(),
		"restrictedRelation" -> restrictedRelation?.uuid()?.toString,
		"restrictedDomain" -> restrictedDomain?.uuid()?.toString, 
		"restrictedRange" -> restrictedRange?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML EntityUniversalRestrictionAxiom maps
 * to an [OWL2 Object Property Universal Restriction].
 */
@Glossary
@DerivedUUID
class EntityUniversalRestrictionAxiom extends EntityRestrictionAxiom {
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"EntityUniversalRestrictionAxiom", 
		"tbox" -> tbox.uuid(),
		"restrictedRelation" -> restrictedRelation?.uuid()?.toString,
		"restrictedDomain" -> restrictedDomain?.uuid()?.toString, 
		"restrictedRange" -> restrictedRange?.uuid()?.toString
		)?.toString
	}
	
}

/*
 * An OML SpecializationAxiom is a logical axiom
 * about a taxonomic relationship between a specific and a general OML Entity.
 */
@Glossary
abstract class SpecializationAxiom extends TermAxiom {
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	op Entity[1] child()
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	op Entity[1] parent()
	
	@Scala(code="scala.collection.immutable.Set.empty[resolver.api.Element]")
	@Collection(kind="Set")
	@NotSchema
	@ImplicitExtent
	op Element[] allNestedElements() { ECollections.emptyEList }
}

/*
 * An OML AspectSpecializationAxiom is a logical axiom
 * about a taxonomic relationship between a specific OML Aspect 
 * and a general OML Entity.
 */
@Glossary
@DerivedUUID
class AspectSpecializationAxiom extends SpecializationAxiom {
	
	/*
	 * The sub (child) entity
	 */
	refers Entity[1] subEntity
	/*
	 * The super (parent) aspect
	 */
	refers Aspect[1] superAspect
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	@Override
	op Entity[1] child() { subEntity }
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	@Override
	op Entity[1] parent() { superAspect }
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"AspectSpecializationAxiom",  
		"tbox" -> tbox.uuid(),
		"superAspect" -> superAspect?.uuid()?.toString,
		"subEntity" -> subEntity?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML ConceptSpecializationAxiom is a logical axiom
 * about a taxonomic relationship between a specific and general
 * OML Concept.
 */
@Glossary
@DerivedUUID
class ConceptSpecializationAxiom extends SpecializationAxiom {
	
	refers Concept[1] subConcept
	refers Concept[1] superConcept
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	@Override
	op Entity[1] child() { subConcept }
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	@Override
	op Entity[1] parent() { superConcept }
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ConceptSpecializationAxiom",
		"tbox" -> tbox?.uuid(),
		"superConcept" -> superConcept?.uuid()?.toString,
		"subConcept" -> subConcept?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML ReifiedRelationshipSpecializationAxiom is a logical axiom
 * about a taxonomic relationship between a specific and general
 * OML ReifiedRelationship.
 */
@Glossary
@DerivedUUID
class ReifiedRelationshipSpecializationAxiom extends SpecializationAxiom {
	
	/*
	 * The sub (child) relationship
	 */
	refers ReifiedRelationship[1] subRelationship
	
	/*
	 * The super (parent) relationship
	 */
	refers ReifiedRelationship[1] superRelationship
	
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	@Override
	op Entity[1] child() { subRelationship }
	
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	@Override
	op Entity[1] parent() { superRelationship }
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ReifiedRelationshipSpecializationAxiom",
		"tbox" -> tbox?.uuid(),
		"superRelationship" -> superRelationship?.uuid()?.toString,
		"subRelationship" -> subRelationship?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML EntityScalarDataPropertyRestrictionAxiom maps to
 * some kind of OWL2 Data Property Restriction.
 */
@Glossary
abstract class EntityScalarDataPropertyRestrictionAxiom extends TermAxiom {
	refers Entity[1] restrictedEntity
  	refers EntityScalarDataProperty[1] scalarProperty
  	
	@Scala(code="scala.collection.immutable.Set.empty[resolver.api.Element]")
	@Collection(kind="Set")
	@NotSchema
	@ImplicitExtent
	op Element[] allNestedElements() { ECollections.emptyEList }
}

/*
 * An OML EntityScalarDataPropertyExistentialRestrictionAxiom maps to an 
 * OWL2 DataSomeValuesFrom restriction (the range must be explicitly defined as a Scalar datatype)
 */
@Glossary
@DerivedUUID
class EntityScalarDataPropertyExistentialRestrictionAxiom 
extends EntityScalarDataPropertyRestrictionAxiom {
	
  	refers DataRange[1] scalarRestriction
  	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"EntityScalarDataPropertyExistentialRestrictionAxiom",
		"tbox" -> tbox?.uuid(),
		"restrictedEntity" -> restrictedEntity?.uuid()?.toString,
		"scalarProperty" -> scalarProperty?.uuid()?.toString,
		"scalarRestriction" -> scalarRestriction?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML EntityScalarDataPropertyUniversalRestrictionAxiom maps to an
 * OWL2 DataAllValuesFrom (the range must be explicitly defined as a Scalar datatype)
 */
@Glossary
@DerivedUUID
class EntityScalarDataPropertyUniversalRestrictionAxiom 
extends EntityScalarDataPropertyRestrictionAxiom {
	
  	refers DataRange[1] scalarRestriction
  	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"EntityScalarDataPropertyUniversalRestrictionAxiom",
		"tbox" -> tbox?.uuid(),
		"restrictedEntity" -> restrictedEntity?.uuid()?.toString,
		"scalarProperty" -> scalarProperty?.uuid()?.toString,
		"scalarRestriction" -> scalarRestriction?.uuid()?.toString
		)?.toString
	}
}

/**
 * An OML EntityScalarDataPropertyParticularRestrictionAxiom maps to an OWL2 DataHasValue restriction.
 */
@Glossary
@DerivedUUID
class EntityScalarDataPropertyParticularRestrictionAxiom
extends EntityScalarDataPropertyRestrictionAxiom {
	
	contains LiteralValue[1] literalValue
  	refers DataRange[?] valueType
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"EntityScalarDataPropertyParticularRestrictionAxiom",
		"tbox" -> tbox?.uuid(),
		"restrictedEntity" -> restrictedEntity?.uuid()?.toString,
		"scalarProperty" -> scalarProperty?.uuid()?.toString
		)?.toString
	}
}

/*
 * An OML EntityStructuredDataPropertyRestrictionAxiom maps to
 * some kind of OWL2 Object Property Restriction.
 */
@Glossary
abstract class EntityStructuredDataPropertyRestrictionAxiom extends TermAxiom {
	refers Entity[1] restrictedEntity
}

/**
 * An OML EntityStructuredDataPropertyParticularRestrictionAxiom maps to an OWL2 ObjectHasValue restriction.
 */
@Glossary
@DerivedUUID
class EntityStructuredDataPropertyParticularRestrictionAxiom
extends EntityStructuredDataPropertyRestrictionAxiom, RestrictionStructuredDataPropertyContext {
  	
  	@Scala(code="extent.terminologyBoxOfTerminologyBoxStatement.get(this)")
	@ImplicitExtent
	@NotSchema
	@Override
	op TerminologyBox[?] terminologyBox() { tbox }
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"EntityStructuredDataPropertyParticularRestrictionAxiom",
		"tbox" -> tbox?.uuid(),
		"restrictedEntity" -> restrictedEntity?.uuid()?.toString,
		"structuredDataProperty" -> structuredDataProperty?.uuid()?.toString
		)?.toString
	}
	
	@Collection(kind="Set")
	@NotSchema
	@ImplicitExtent
	op Element[] allNestedElements() { allNestedRestrictionElements }
}

/*
 * An OML RestrictionStructuredDataPropertyContext defines the context of
 * an OML DataRelationshipToStructure for an OML Entity restriction for specifying
 * values of the OML DataRelationshipFromStructure properties
 */
@Glossary
@DerivedUUID
abstract class RestrictionStructuredDataPropertyContext extends ModuleElement {
	
	refers DataRelationshipToStructure[1] structuredDataProperty
	
	@Collection(kind="Set")
	contains RestrictionStructuredDataPropertyTuple[] structuredDataPropertyRestrictions opposite structuredDataPropertyContext
	
	@Collection(kind="Set")
	contains RestrictionScalarDataPropertyValue[] scalarDataPropertyRestrictions opposite structuredDataPropertyContext
	
	@ImplicitExtent
	@NotSchema
	op TerminologyBox[?] terminologyBox()
	
	@Scala(code="extent.lookupStructuredDataPropertyRestrictions(this).flatMap{ r => scala.collection.immutable.Set.empty[resolver.api.Element] + r ++ r.allNestedRestrictionElements() } ++
		extent.lookupScalarDataPropertyRestrictions(this)")
	@Collection(kind="Set")
	@NotSchema
	@ImplicitExtent
	op Element[] allNestedRestrictionElements() { 
		val nres = new BasicEList<Element>()
		nres.addAll(structuredDataPropertyRestrictions)
		structuredDataPropertyRestrictions.forEach[ nres.addAll(allNestedRestrictionElements) ]
		nres.addAll(scalarDataPropertyRestrictions)
		nres
	}
}

/*
 * An OML RestrictionStructuredDataPropertyTuple is an OML RestrictionStructuredDataPropertyContext
 * nested in a container OML RestrictionStructuredDataPropertyContext.
 */
@Glossary
@DerivedUUID
class RestrictionStructuredDataPropertyTuple extends RestrictionStructuredDataPropertyContext {
	
	@Factory
	container RestrictionStructuredDataPropertyContext[1] structuredDataPropertyContext opposite structuredDataPropertyRestrictions
	
	@Scala(code="extent.restrictionStructuredDataPropertyContextOfRestrictionStructuredDataPropertyTuple.get(this).flatMap(_.terminologyBox())")
	@ImplicitExtent
	@NotSchema
	@Override
	op TerminologyBox[?] terminologyBox() { structuredDataPropertyContext?.terminologyBox }
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"RestrictionStructuredDataPropertyTuple", 
		"structuredDataPropertyContext" -> structuredDataPropertyContext?.uuid()?.toString(),
		"structuredDataProperty" -> structuredDataProperty?.uuid()?.toString()
		)?.toString
	}
	
	@Scala(code="extent.restrictionStructuredDataPropertyContextOfRestrictionStructuredDataPropertyTuple.get(this).flatMap(_.moduleContext)")
	@NotSchema
	@ImplicitExtent
	op Module[?] moduleContext() {
		structuredDataPropertyContext?.moduleContext
	}
	
	@Collection(kind="Set")
	@NotSchema
	@ImplicitExtent
	op Element[] allNestedElements() { allNestedRestrictionElements }
}

/*
 * An OML RestrictionScalarDataPropertyValue specifies a literal string as the value of 
 * an OML DataRelationshipToScalar in the scope of an OML RestrictionStructuredDataPropertyContext.
 */
@Glossary
@DerivedUUID
class RestrictionScalarDataPropertyValue extends Element {
	
	@Factory
	container RestrictionStructuredDataPropertyContext[1] structuredDataPropertyContext opposite scalarDataPropertyRestrictions
	
	refers DataRelationshipToScalar[1] scalarDataProperty
	contains LiteralValue[1] scalarPropertyValue
	refers DataRange[?] valueType
	
	@Scala(code="extent.restrictionStructuredDataPropertyContextOfRestrictionScalarDataPropertyValue.get(this).flatMap(_.terminologyBox())")
	@ImplicitExtent
	@NotSchema
	op TerminologyBox[?] terminologyBox() { structuredDataPropertyContext?.terminologyBox }
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"RestrictionScalarDataPropertyValue", 
		"structuredDataPropertyContext" -> structuredDataPropertyContext?.uuid()?.toString(),
		"scalarDataProperty" -> scalarDataProperty?.uuid()?.toString()
		)?.toString
	}
	
	@Scala(code="extent.restrictionStructuredDataPropertyContextOfRestrictionScalarDataPropertyValue.get(this).flatMap(_.moduleContext)")
	@NotSchema
	@ImplicitExtent
	op Module[?] moduleContext() {
		structuredDataPropertyContext?.moduleContext
	}
}

/*
 * An OML RestrictedDataRange corresponds to an [OWL2 DataRange] defined
 * in terms of some kind of restriction of some other OML DataRange.
 * The specializations of OML RestrictedDataRange correspond to
 * the allowed restrictions in the [OWL2 Datatype Maps].
 * Node that the vocabulary of XSD fundamental facets is not included in OWL2-DL, consequently, 
 * there is no support in OML for specifying datatype restrictions involving XSD fundamental facets as well.
 * Each specialization maps to an OWL2 Declaration of an [OWL2 Datatype] whose
 * [OWL2 DataRange] corresponds to the OWL2 mapping of that specialized restriction.
 */ 
@Glossary
abstract class RestrictedDataRange extends DataRange {
	/*
	 * The restricted (general) data range of this data range (specific)
	 */
	refers DataRange[1] restrictedRange
}

/*
 * An OML BinaryScalarRestriction is a data range that specifies how one binary scalar adds facet restrictions to another.
 * Applicable when the restricted scalar represents [OWL2 Binary Data].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [xsd:base64Binary]
 * - [xsd:hexBinary]
 * 
 * Facets:
 * - [xsd:length]
 * - [xsd:minLength]
 * - [xsd:maxLength]
 */
@Glossary
class BinaryScalarRestriction extends RestrictedDataRange {
	
	/*
	 * The length of the binary data
	 */
	PositiveIntegerLiteral[?] length
	/*
	 * The minimum length of the binary data
	 */
	PositiveIntegerLiteral[?] minLength
	/*
	 * The maximum length of the binary data
	 */
	PositiveIntegerLiteral[?] maxLength
}

/*
 * An OML IRIScalarRestriction is a data range that specifies how one IRI scalar adds facet restrictions to another.
 * Applicable when the restricted scalar represents an [OWL2 IRI].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [xsd:anyURI]
 * 
 * Facets:
 * - [xsd:length]
 * - [xsd:minLength]
 * - [xsd:maxLength]
 * - [xsd:pattern]
 */
@Glossary
class IRIScalarRestriction extends RestrictedDataRange {
	
	/*
	 * The length of the IRI
	 */
	PositiveIntegerLiteral[?] length
	/*
	 * The minimum length of the IRI
	 */
	PositiveIntegerLiteral[?] minLength
	/*
	 * The maximum length of the IRI
	 */
	PositiveIntegerLiteral[?] maxLength
	/*
	 * The pattern of the IRI (https://www.w3.org/TR/xmlschema-2/#regexs)
	 */
	LiteralPattern[?] pattern
}

/*
 * An OML NumericScalarRestriction is a data range that specifies how one numeric scalar range adds facet restrictions to another.
 * Applies when the restricted scalar represents [OWL2 Real Numbers, Decimal Numbers and Integers] or [OWL2 Floating-Point Numbers].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [owl:real]
 * - [owl:rational]
 * - [xsd:decimal]
 * - [xsd:integer]
 * - [xsd:nonNegativeInteger]
 * - [xsd:nonPositiveInteger]
 * - [xsd:positiveInteger]
 * - [xsd:negativeInteger]
 * - [xsd:long]
 * - [xsd:int]
 * - [xsd:short]
 * - [xsd:byte]
 * - [xsd:unsignedLong]
 * - [xsd:unsignedInt]
 * - [xsd:unsignedShort]
 * - [xsd:unsignedByte]
 * - [xsd:double]
 * - [xsd:float]
 * 
 * Facets:
 * - [xsd:minInclusive]
 * - [xsd:maxInclusive]
 * - [xsd:minExclusive]
 * - [xsd:maxExclusive]
 */
@Glossary
class NumericScalarRestriction extends RestrictedDataRange {
	
	/*
	 * The inclusive minimum value in the range
	 */
	contains LiteralNumber[?] minInclusive
	/*
	 * The inclusive maximum value in the range
	 */
	contains LiteralNumber[?] maxInclusive
	/*
	 * The exclusive minimum value in the range
	 */
	contains LiteralNumber[?] minExclusive
	/*
	 * The exclusive maximum value in the range
	 */
	contains LiteralNumber[?] maxExclusive
}

/*
 * An OML PlainLiteralScalarRestriction is a data range that specifies how one plain literal scalar adds facet restrictions to another.
 * Applicable when the restricted scalar represents [rdf:PlainLiteral].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [rdf:PlainLiteral]
 * 
 * Facets:
 * - [xsd:langRange]
 * - [xsd:length]
 * - [xsd:minLength]
 * - [xsd:maxLength]
 * - [xsd:pattern]
 */
@Glossary
class PlainLiteralScalarRestriction extends RestrictedDataRange {
	
	/*
	 * The length of the plain literal
	 */
	PositiveIntegerLiteral[?] length
	/*
	 * The minimum length of the plain literal
	 */
	PositiveIntegerLiteral[?] minLength
	/*
	 * The maximum length of the plain literal
	 */
	PositiveIntegerLiteral[?] maxLength
	/*
	 * The pattern of the plain literal (https://www.w3.org/TR/xmlschema-2/#regexs)
	 */
	LiteralPattern[?] pattern
	/*
	 * The language of the plain literal (http://www.rfc-editor.org/rfc/bcp/bcp47.txt)
	 */
	LanguageTagDataType[?] langRange
}

/*
 * An OML StringScalarRestriction is a data range that specifies how one string scalar adds facet restrictions to another.
 * Applicable when the restricted scalar represents [OWL2 Strings].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [xsd:string]
 * - [xsd:normalizedString]
 * - [xsd:token]
 * - [xsd:language]
 * - [xsd:Name]
 * - [xsd:NCName]
 * - [xsd:NMTOKEN]
 * 
 * Facets:
 * - [xsd:length]
 * - [xsd:minLength]
 * - [xsd:maxLength]
 * - [xsd:pattern]
 */
@Glossary
class StringScalarRestriction extends RestrictedDataRange {
	
	/*
	 * The length of the string
	 */
	PositiveIntegerLiteral[?] length
	/*
	 * The minimum length of the string
	 */
	PositiveIntegerLiteral[?] minLength
	/*
	 * The maximum length of the string
	 */
	PositiveIntegerLiteral[?] maxLength
	/*
	 * The pattern of the string (https://www.w3.org/TR/xmlschema-2/#regexs)
	 */
	LiteralPattern[?] pattern
}

/*
 * An OML TimeScalarRestriction is a data range that specifies how one time scalar adds facet restrictions to another.
 * Applicable when the restricted scalar represents [OWL2 Time Instants].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [xsd:dateTime]
 * - [xsd:dateTimeStamp]
 * 
 * Facets:
 * - [xsd:minInclusive]
 * - [xsd:maxInclusive]
 * - [xsd:minExclusive]
 * - [xsd:maxExclusive]
 */
@Glossary
class TimeScalarRestriction extends RestrictedDataRange {
	
	/*
	 * The inclusive minimum value in the range
	 */
	contains LiteralDateTime[?] minInclusive
	/*
	 * The inclusive maximum value in the range
	 */
	contains LiteralDateTime[?] maxInclusive
	/*
	 * The exclusive minimum value in the range
	 */
	contains LiteralDateTime[?] minExclusive
	/*
	 * The exclusive maximum value in the range
	 */
	contains LiteralDateTime[?] maxExclusive
}

/*
 * An OML SynonymScalarRestriction is a data range that is defined as a synonym for another (i.e. the restrictedRange).
 */
@Glossary
class SynonymScalarRestriction extends RestrictedDataRange {
}

/*
 * An OML ScalarOneOfRestriction is a data range that specifies how a scalar is a restricted set of literal values of another.
 * Semantics: OWL2 DataOneOf
 */
@Glossary
class ScalarOneOfRestriction extends RestrictedDataRange {
}

/*
 * An OML ScalarOneOfLiteralAxiom specifies a literal in a ScalarOneOfRestriction data range.
 */
@Glossary
@DerivedUUID
class ScalarOneOfLiteralAxiom extends TermAxiom {
	
	refers ScalarOneOfRestriction[1] axiom
	
	/*
	 * The value of the literal from the restrictedScalar datatype
	 */
	contains LiteralValue[1] value
	refers DataRange[?] valueType
	
	@NotFunctionalAPI
	@NotSchema
	op UUID[1] uuid() {
		OMLExtensions.derivedUUID(
		"ScalarOneOfLiteralAxiom",
		"tbox" -> tbox?.uuid()?.toString,
		"axiom" -> axiom?.uuid()?.toString
		)?.toString
	}
	
	@Scala(code="scala.collection.immutable.Set.empty[resolver.api.Element]")
	@Collection(kind="Set")
	@NotSchema
	@ImplicitExtent
	op Element[] allNestedElements() { ECollections.emptyEList }
}
